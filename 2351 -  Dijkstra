#include <bits/stdc++.h>
using namespace std;
const int INF = INT_MAX;
int n, s, f;
vector<int> dist;
vector<int> parent;

void djk(const vector<vector<int>>& arr) {
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
    pq.push({0, s - 1});

    while (!pq.empty()) {
        int dis = pq.top().first;
        int node = pq.top().second;
        pq.pop();

        for (int i = 0; i < n; i++) {
            if (arr[node][i] > 0) {
                int edgeWeight = arr[node][i];
                int adjNode = i;

                if (dis + edgeWeight < dist[adjNode]) {
                    dist[adjNode] = dis + edgeWeight;
                    pq.push({dist[adjNode], adjNode});
                    parent[adjNode] = node;  // Store the predecessor
                }
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> s >> f;
    vector<vector<int>> arr(n, vector<int>(n));
    dist.resize(n, INF);
    parent.resize(n, -1);
    dist[s - 1] = 0;

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            cin >> arr[i][j];
        }
    }

    djk(arr);

    if (dist[f - 1] == INF) {
        cout << -1; 
    } else {
        cout << dist[f - 1] << "\n";

        // Restore the path
        vector<int> path;
        for (int at = f - 1; at != -1; at = parent[at]) {
            path.push_back(at + 1);  // Convert to 1-based index
        }
        reverse(path.begin(), path.end());

        if (path[0] == s) {
            for (int node : path) {
                cout << node << " ";
            }
        }
    }

    return 0;
}
